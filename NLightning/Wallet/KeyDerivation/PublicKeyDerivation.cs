using NLightning.Cryptography;
using NLightning.Utils.Extensions;
using Org.BouncyCastle.Math;
using Org.BouncyCastle.Math.EC;

namespace NLightning.Wallet.KeyDerivation
{
    public class PublicKeyDerivation
    {
        private readonly ECKeyPair _perCommitmentPoint;

        public PublicKeyDerivation(ECKeyPair perCommitmentPoint)
        {
            _perCommitmentPoint = perCommitmentPoint;
        }

        /* BOLT #3:
         *
         * ### `localpubkey`, `remotepubkey`, `local_htlcpubkey`, `remote_htlcpubkey`, `local_delayedpubkey`, and `remote_delayedpubkey` Derivation
         *
         * These pubkeys are simply generated by addition from their base points:
         *
         * 	pubkey = basepoint + SHA256(per_commitment_point || basepoint) * G
         *
         * The `localpubkey` uses the local node's `payment_basepoint`; the
         * `remotepubkey` uses the remote node's `payment_basepoint`; the
         * `local_delayedpubkey` uses the local node's `delayed_payment_basepoint`; the
         * `local_htlcpubkey` uses the local node's `htlc_basepoint`; and the
         * `remote_delayedpubkey` uses the remote node's `delayed_payment_basepoint`.
         */
        public ECKeyPair Derive(ECKeyPair basePoint)
        {
            var hash = new BigInteger(1, HashPoints(_perCommitmentPoint, basePoint));
            var multiplResult = ECKeyPair.Secp256K1.G.Multiply(hash);
            return new ECKeyPair(basePoint.PublicKeyParameters.Q.Add(multiplResult).Normalize().GetEncoded(true), false);
        }

        private static byte[] HashPoints(ECKeyPair point1, ECKeyPair point2)
        {
            return SHA256.ComputeHash(point1.PublicKeyCompressed.ConcatToNewArray(point2.PublicKeyCompressed));
        }
    }
}